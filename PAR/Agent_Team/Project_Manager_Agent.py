import operator
from typing import Literal, TypedDict, Annotated, Union

from langchain_core.agents import AgentAction, AgentFinish
from langchain_core.messages import HumanMessage
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_core.pydantic_v1 import BaseModel, Field
from langgraph.graph import StateGraph

from Agent_Team.Member.Common_Search_AgentGraph import TavilySearchAgentGraph, BraveSearchAgentGraph, WikipediaSearchAgentGraph, YoutubeSearchAgentGraph, ArxivSearchAgentGraph
from Agent_Team.Member.PAR_Document_Writer import get_document_generation_agent
from CustomHelper.Anthropic_helper import format_to_anthropic_tool_messages
from CustomHelper.Custom_AnthropicAgentOutputParser import AnthropicAgentOutputParser_beta
from CustomHelper.Helper import retry_with_delay_async
from CustomHelper.load_model import get_anthropic_model
from Util.PAR_Helper import extract_result

members = ["tavily_agent", "document_agent", "wikipedia_agent", "youtube_agent", "arxiv_agent", "brave_agent"]


class route(BaseModel):
    """Select the next agent.
    Remember the next agent can't access provided section. So you MUST provide specific and clear instructions to next agent."""
    next: Literal[
        "tavily_agent", "document_agent", "wikipedia_agent", "youtube_agent", "arxiv_agent", "brave_agent"] = Field(...,
                                                                                                               description="Select the next agent")
    instructions: str = Field(...,
                              description="Provide specific, clear, and detailed instructions that next agent what should do.")

def _get_PM_agent():
    PM_Prompt = ChatPromptTemplate.from_messages([
        ("system", """You are a highly experienced and perfect Project Manager Agent who has worked in this role for a long time.

    You are now in charge of a project called "PAR" to write a specific section of an entire MarkDown document. Other sections will be handled by different Project Manager Agents.

    Your team consists of agents specialized in different search engines and an agent dedicated to document generation.

    Your role is to effectively coordinate and collaborate with your team memebers to create a perfect section of the document when provided with overall guidelines and content for the specific section.

    <instructions>
    1. Thoroughly analyze the section information to identify the necessary search engines and queries for each agent in 'search agents'. Provide then with clear instructions and specific search requests.

    2. When evaluating the search results from each agent, rigorously assess them using the criteria within the <search_evaluation> XML tag. Only accept results that meet a threshold of 4 points or higher. If the results are insufficient, provide detailed feedback to the respective agent and request additional searches.

    3. Once you have collected sufficient high-quality information, call upon the 'document generation agent'. Provide the agent with the following information and guidelines specified in the <document_writing_guidelines> XML tag.

    4. Review the output from the 'document generation agent'. Evaluate the generated document according to the criteria in item 6 of the <document_writing_guidelines>. If the document does not score above 4 points, provide detailed feedback and request revisions.

    5. Once the final document meets the required standards, deliver it to the user. Throughout the process, adhere to the following <restrictions> XML tag.

    6. When providing instructions to the agents, keep in mind that the selected agents do not have access to the section content. Therefore, provide specific and clear instructions to the selected agents.
    <instructions>

    <restrictions>
    1. Exclude sources that are unreliable or low in quality.
    2. Be mindful not to exceed the allocated time and resources for search and document creation.
    3. Do not cover content beyond the scope of the given section.
    4. Thoroughly review the generated document for any errors or inappropriate content.
    5. Maintain smooth and respectful interactions among agents.
    6. Thoroughly review the search results performed by the each search agents according to the items within the <search_evaluation></search_evaluation> XML tag. If the search results do not score above a total of 4 points, provide detailed feedback and re-request the respective agent.
    7. Document generation must be performed exclusively through the document generation agent. Your role is to create a instructions for document generation based on the search results provided by each search agents, deliver these instructions to the document generation agent, and review the generated document. 
    8. Verify the final section document generated by the document generation agent according to the document evaluation criteria in item 6 of the <document_writing_guidlines></document_writing_guidlines> XML tag. If the document evaluation score is not above 4 points, provide detailed feedback and re-request the respective agent.
    </restrictions>


    <search_evaluation>
    1. Relevance to the section topic
    - Evaluate whether the search result is directly related to the section's title, description, and key content.
    - Assess the degree of relevance on a scale of 1 (very low) to 5 (very high).
    - Only accept search results with a relevance score of 4 or higher.
    2. Quality and reliability of the information
    - Verify if the source of the search result is a reputable institution, expert, or academic material.
    - Check the recency of the information and exclude outdated or non-updated content.
    - Evaluate the accuracy and objectivity of the information, discarding subjective or biased content.
    3. Comprehensiveness and diversity of the content
    - Assess whether the search result covers the section topic from various perspectives.
    - Ensure that the key content to be covered in the section is comprehensively included.
    - Check if various examples, cases, and data are included.
    4. Usefulness for document creation
    - Determine if the search result contains information that is practically helpful for writing the section.
    - Consider whether the content can support the explanation, flow, and argumentation of the section.
    - Evaluate if the information from the search result can enhance readability and comprehension when utilized in the document.
    5. Consistency and contradiction check of search results.
    - Verify the consistency of information across multiple search agent's results.
    - Thoroughly review if there are any contradictory contents, and exclude the search results with contradictions if found.
    </search_evaluation>


    <document_writing_guidelines>
    1. Section title and description
    - Clearly understand the given section title and description, and write the document based on them.
    - Faithfully reflect the content specified in the title and description, adding supplementary explanations if necessary.
    2. Key content and keywords
    - Identify the key content and keywords that must be covered in the section and appropriately incorporate them into the document.
    - Structure the document around the key content and utilize keywords to emphasize important concepts and topics.
    3. Reference search results and sources
    - Actively utilize the provided search results and sources to write the document.
    - Clearly cite the sources when quoting or referencing information from the search results, adhering to copyright guidelines.
    - Rather than directly copying the search results, understand the content and reconstruct it in your own words.
    4. Document tone and style
    - Consistently write the document in accordance with the markdown style guide.
    - Maintain a professional and objective tone while keeping it approachable for the reader.
    - Focus on providing information and explanations that align with the document's objectives and help the reader's understanding.
    - Using emojis to avoid a rigid atmosphere of section.
    5. Document structure and length
    - Follow the suggested document structure while considering the logical flow and connectivity of the content.
    - Adhere to the length guidelines but prioritize the thoroughness and completeness of the content.
    - If necessary, divide the section into subsections to deliver information systematically.
    6. Document evaluation criteria
    - Verify if the document content aligns with the section title and description.
    - Evaluate whether the document comprehensively covers the keywords and key content.
    - Check if the document structure and flow are logical and easy to read.
    - Thoroughly check for any errors in grammar, spelling, and expressions.
    - Confirm if the referenced search results and sources are properly cited.
    - Verify the document's prioritize the completeness of the content.
    </document_writing_guidelines>

    As the Project Manager Agent, strive to coordinate your team members effectively based on the above guidelines and constraints to create a high-quality section of the document.
    """),
        ("human", "<section_information>\n{input}\n</section_information>"),
        MessagesPlaceholder(variable_name="agent_scratchpad")
    ])

    PM_llm = get_anthropic_model(model_name="sonnet")

    PM_chain = (
            {
                "input"           : lambda x: x["input"],
                "agent_scratchpad": lambda x: format_to_anthropic_tool_messages(x["intermediate_steps"])
            }
            | PM_Prompt
            | PM_llm.bind_tools(tools=[route]).with_fallbacks([PM_llm.bind_tools(tools=[route])] * 3)
            | AnthropicAgentOutputParser_beta()
    )
    return PM_chain


class AgentState(TypedDict):
    order: int
    input: str
    agent_output: Union[AgentAction, AgentFinish, None]
    intermediate_steps: Annotated[list[tuple[AgentAction, str]], operator.add]
    next: str
    instructions: str
    search_result: str
    final_section_document: str


def transform_search_result(search_engine: str, search_result: str) -> str:
    return f"<{search_engine}_search_result>\n\n{search_result}\n\n</{search_engine}_search_result>"


async def run_pm_agent(state: AgentState) -> dict:
    print("### PM AGENT RUN ###")
    PM_chain = _get_PM_agent()
    pm_result = await retry_with_delay_async(
        chain=PM_chain,
        input={
            "input": state["input"],
            "intermediate_steps": state["intermediate_steps"],
        },
        max_retries=5,
        delay_seconds=45.0
    )
    # pm_result = await PM_chain.ainvoke({"input": state["input"], "intermediate_steps": state["intermediate_steps"]})

    if isinstance(pm_result, list) and len(pm_result) > 0:
        _next = pm_result[0].tool_input["next"]

        if 'human' in _next:
            return {
                "agent_output": pm_result[0],
                "next": "FINISH",
                "final_section_document": state["final_section_document"],
            }

        return {
            "agent_output": pm_result[0],
            "next": pm_result[0].tool_input["next"],
            "instructions": pm_result[0].tool_input["instructions"],
        }
    elif isinstance(pm_result, AgentFinish):
        return {
            "agent_output": pm_result,
            "next": "FINISH",
            "final_section_document": state["final_section_document"],
        }
    else:
        raise ValueError(f"Unexpected agent output: {pm_result}, type: {type(pm_result)}")


async def tavily_agent_node(state: AgentState) -> dict:
    PAR_Team_Member_Agent_Tavily = TavilySearchAgentGraph()
    print(f"---{state['order']} PM AGENT CALLED TAVILY AGENT---")
    messages = HumanMessage(content=f"Hi! I'm PAR Project Manager Agent! {state['instructions']}")
    tavily_agent_result = await PAR_Team_Member_Agent_Tavily.get_search_agent_graph().ainvoke({"input": messages.content})
    extract_tavily_agent_result = extract_result(tavily_agent_result["agent_outcome"].return_values["output"])
    tavily_search_result = transform_search_result(search_engine="Tavily", search_result=extract_tavily_agent_result)
    return {
        "intermediate_steps": [(state["agent_output"], extract_tavily_agent_result)],
        "search_result": state["search_result"] + "\n\n" + tavily_search_result
    }


async def brave_agent_node(state: AgentState) -> dict:
    PAR_Team_Member_Agent_Brave = BraveSearchAgentGraph()
    print(f"---{state['order']} PM AGENT CALLED BRAVE AGENT---")
    messages = HumanMessage(content=f"Hi! I'm PAR Project Manager Agent! {state['instructions']}")
    brave_agent_result = await PAR_Team_Member_Agent_Brave.get_search_agent_graph().ainvoke({"input": messages.content})
    extract_brave_agent_result = extract_result(brave_agent_result["agent_outcome"].return_values["output"])
    brave_search_result = transform_search_result(search_engine="BraveSearch", search_result=extract_brave_agent_result)
    return {
        "intermediate_steps": [(state["agent_output"], extract_brave_agent_result)],
        "search_result": state["search_result"] + "\n\n" + brave_search_result
    }


async def wikipedia_agent_node(state: AgentState) -> dict:
    PAR_Team_Member_Agent_Wikipedia = WikipediaSearchAgentGraph()
    print(f"---{state['order']} PM AGENT CALLED WIKIPEDIA AGENT---")
    messages = HumanMessage(content=f"Hi! I'm PAR Project Manager Agent! {state['instructions']}")
    wikipedia_agent_result = await PAR_Team_Member_Agent_Wikipedia.get_search_agent_graph().ainvoke({"input": messages.content})
    extract_wikipedia_agent_result = extract_result(wikipedia_agent_result["agent_outcome"].return_values["output"])
    wikipedia_search_result = transform_search_result(search_engine="Wikipedia",
                                                      search_result=extract_wikipedia_agent_result)
    return {
        "intermediate_steps": [(state["agent_output"], extract_wikipedia_agent_result)],
        "search_result": state["search_result"] + "\n\n" + wikipedia_search_result
    }


async def youtube_agent_node(state: AgentState) -> dict:
    PAR_Team_Member_Agent_Youtube = YoutubeSearchAgentGraph()
    print(f"---{state['order']} PM AGENT CALLED YOUTUBE AGENT---")
    messages = HumanMessage(content=f"Hi! I'm PAR Project Manager Agent! {state['instructions']}")
    youtube_agent_result = await PAR_Team_Member_Agent_Youtube.get_search_agent_graph().ainvoke({"input": messages.content})
    extract_youtube_agent_result = extract_result(youtube_agent_result["agent_outcome"].return_values["output"])
    youtube_search_result = transform_search_result(search_engine="Youtube", search_result=extract_youtube_agent_result)
    return {
        "intermediate_steps": [(state["agent_output"], extract_youtube_agent_result)],
        "search_result": state["search_result"] + "\n\n" + youtube_search_result
    }


async def arXiv_agent_node(state: AgentState) -> dict:
    PAR_Team_Member_Agent_ArXiv = ArxivSearchAgentGraph()
    print(f"---{state['order']} PM AGENT CALLED ARXIV AGENT---")
    messages = HumanMessage(content=f"Hi! I'm PAR Project Manager Agent! {state['instructions']}")
    arxiv_agent_result = await PAR_Team_Member_Agent_ArXiv.get_search_agent_graph().ainvoke({"input": messages.content})
    extract_arxiv_agent_result = extract_result(arxiv_agent_result["agent_outcome"].return_values["output"])
    arxiv_search_result = transform_search_result(search_engine="ArXiv", search_result=extract_arxiv_agent_result)
    return {
        "intermediate_steps": [(state["agent_output"], extract_arxiv_agent_result)],
        "search_result": state["search_result"] + "\n\n" + arxiv_search_result
    }


async def document_agent_node(state: AgentState) -> dict:
    Document_Writer_chain = get_document_generation_agent()
    print(f"---{state['order']} PM AGENT CALLED DOCUMENT GENERATOR AGENT---")
    messages = HumanMessage(content=f"Hi! I'm PAR Project Manager Agent! {state['instructions']}")
    document_agent_result = await retry_with_delay_async(
        chain=Document_Writer_chain,
        input={
            "input": messages.content,
            "search_result": state["search_result"]
        },
        max_retries=5,
        delay_seconds=60.0
    )
    return {
        "final_section_document": document_agent_result,
        "intermediate_steps": [(state["agent_output"], document_agent_result)],
    }


def response_node(state: AgentState) -> dict:
    print(f"### {state['order']} PM AGENT DONE ALL WORK ###")
    return {
        "agent_output": state["agent_output"],
        "final_section_document": state["final_section_document"],
        "order": state["order"],
    }


def get_pm_graph():
    workflow = StateGraph(AgentState)
    workflow.add_node("manager", run_pm_agent)
    workflow.add_node("tavily_agent", tavily_agent_node)
    workflow.add_node("brave_agent", brave_agent_node)
    workflow.add_node("document_agent", document_agent_node)
    workflow.add_node("wikipedia_agent", wikipedia_agent_node)
    workflow.add_node("youtube_agent", youtube_agent_node)
    workflow.add_node("arxiv_agent", arXiv_agent_node)
    workflow.add_node("response", response_node)

    for member in members:
        workflow.add_edge(member, "manager")

    conditional_map = {k: k for k in members}
    conditional_map["FINISH"] = "response"
    workflow.add_conditional_edges("manager", lambda x: x["next"], conditional_map)
    workflow.set_entry_point("manager")
    workflow.set_finish_point("response")
    project_manager_graph = workflow.compile().with_config(run_name="Project Manager Agent")

    return project_manager_graph


def get_pm_graph_mermaid():
    app = get_pm_graph()
    print(app.get_graph().draw_mermaid())